/* autogenerated by Processing revision 1293 on 2023-11-09 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import fr.dgac.ivy.*;
import fr.dgac.ivy.tools.*;
import gnu.getopt.*;

import java.awt.Point;
import fr.dgac.ivy.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Palette extends PApplet {

/*
 * Palette Graphique - prélude au projet multimodal 3A SRI
 * 4 objets gérés : cercle, rectangle(carré), losange et triangle
 * (c) 05/11/2019
 * Dernière révision : 28/04/2020
 */




ArrayList<Forme> formes; // liste de formes stockées
FSM mae; // Finite Sate Machine
int indice_forme;
PImage sketch_icon;
Data data_en_cours = new Data();

Ivy bus;

public void setup() {
  int WIDTH = 800;
  int HEIGHT = 600;
  /* size commented out by preprocessor */;
  surface.setResizable(true);
  surface.setTitle("Palette multimodale");
  surface.setLocation(displayWidth/2 - WIDTH/2, displayHeight/2- HEIGHT/2);
  sketch_icon = loadImage("Palette.jpg");
  surface.setIcon(sketch_icon);

  formes= new ArrayList(); // nous créons une liste vide
  noStroke();
  mae = FSM.INITIAL;
  indice_forme = -1;

  try
  {
    bus = new Ivy("Palette", " Palette is ready", null);
    bus.start("127.255.255.255:2010");

    bus.bindMsg("^OneDolarIvy Template=(.*) Confidence=(.*)", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        System.out.println("Received forme"+ args[0]);
        if (args[0] != "NONE") {
          //System.out.println("Received forme");

          String shape_string = args[0];
          data_en_cours.setShape(shape_string);

          System.out.println(data_en_cours);

          if (data_en_cours.action.equals("DELETE") && data_en_cours.shape != null) {
            mae = FSM.REALISATION_ACTION;
          } else if (data_en_cours.isDataCompleted()) {
            mae=FSM.REALISATION_ACTION;
          } else {
            mae=FSM.EN_ATTENTE_INFORMATIONS;
          }
        } else {
          System.out.println("Forme inconnue");
        }
      }
    }
    );

    bus.bindMsg("^sra5 Parsed=action=(.*) where=(.*) form=(.*) color=(.*) localisation=(.*) Confidence=(.*) NP=(.*) Num_A=(.*)", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        String act = args[0];
        String shape_string = args[2];
        String color_string = args[3];
        System.out.println("Received parole");

        data_en_cours.setAction(act);
        data_en_cours.setColor(color_string); // if empty will be set to null
        data_en_cours.setShape(shape_string); // if empty will be set to null

        System.out.println(data_en_cours);
        if (data_en_cours.action.equals("DELETE") && data_en_cours.shape != null) {
          mae = FSM.REALISATION_ACTION;
        } else if (data_en_cours.isDataCompleted()) {
          mae = FSM.REALISATION_ACTION;
        } else {
          mae = FSM.EN_ATTENTE_INFORMATIONS;
        }
      }
    }
    );

    // reset state
    //bus.bindMsg("^sra5 Event=Speech_Rejected", new IvyMessageListener()
    //{
    //  public void receive(IvyClient client, String[] args)
    //  {
    //    System.out.println("Received reset");
    //    data_en_cours.reset();
    //    System.out.println(data_en_cours);
    //    mae=FSM.IDLE;
    //  }
    //}
    //);
  }
  catch (IvyException ie) {
  }
}

public void draw() {
  background(0);
  //println("MAE : " + mae );
  switch (mae) {
  case INITIAL:  // Etat INITIAL
    background(255);
    fill(0);
    text("Projet fusion multimodale UPSSITECH", 50, 50);
    text("Julian TRANI & Pauline JOBERT 3A", 50, 80);
    text("Bienvenue sur le moteur de fusion (Palette)", 50, 110);
    text("r : reset la trame de données", 50, 140);
    break;

  case IDLE:
  case EN_ATTENTE_INFORMATIONS:
    affiche();
    break;

  case REALISATION_ACTION:
    println("REALISATION_ACTION");
    switch(data_en_cours.action) {
    case "CREATE":
      formes.add(data_en_cours.getForme());
      data_en_cours.reset();
      break;

    case "MOVE":
      for (int i=formes.size()-1; i>=0; i--) {
        if (formes.get(i).c_color == data_en_cours.color_i && formes.get(i).shape == data_en_cours.shape) {
          formes.get(i).setLocation(data_en_cours.location);
          break;
        }
      }
      data_en_cours.reset();
      break;

    case "DELETE":
      for (int i=formes.size()-1; i>=0; i--) {
        if (formes.get(i).c_color == data_en_cours.color_i && formes.get(i).shape == data_en_cours.shape) {
          formes.remove(i);
          break;
        }
      }
      data_en_cours.reset();
      break;
    default:
      break;
    }
    mae = FSM.IDLE;
    break;

  default:
    break;
  }
}

// fonction d'affichage des formes m
public void affiche() {
  background(255);
  fill(0);
  text("r : reset la trame de données", 10, 20);

  if (data_en_cours.location != null) {
    fill(0);
    circle((int) data_en_cours.location.getX(), (int) data_en_cours.location.getY(), 5);
  }

  /* afficher tous les objets */
  for (int i=0; i<formes.size(); i++) // on affiche les objets de la liste
    (formes.get(i)).update();
}

public void mousePressed() { // sur l'événement clic
  Point p = new Point(mouseX, mouseY);

  data_en_cours.setLocationPoint(p);
  System.out.println(data_en_cours);
  if (data_en_cours.isDataCompleted()) {
    mae=FSM.REALISATION_ACTION;
  } else {
    mae=FSM.EN_ATTENTE_INFORMATIONS;
  }
}


public void keyPressed() {
  switch(key) {
  case 'r':
    data_en_cours.reset();
    System.out.println("Reset data");
    System.out.println(data_en_cours);
    break;
  }
}

/*
 * Classe Cercle
 */ 
 
public class Cercle extends Forme {  
  int rayon;
  
  public Cercle(Point p) {
    super(p);    
    this.shape = Shape.CIRCLE;
    this.rayon=80;
  }
   
  public void update() {
    fill(this.c);
    circle((int) this.origin.getX(),(int) this.origin.getY(),this.rayon);
  }  
   
  public boolean isClicked(Point p) {
    // vérifier que le cercle est cliqué
   PVector OM= new PVector( (int) (p.getX() - this.origin.getX()),(int) (p.getY() - this.origin.getY())); 
   if (OM.mag() <= this.rayon/2)
     return(true);
   else 
     return(false);
  }
  
  protected double perimetre() {
    return(2*PI*this.rayon);
  }
  
  protected double aire(){
    return(PI*this.rayon*this.rayon);
  }
}

public enum Couleur {
  ROUGE(236, 112, 99),
    VERT(154, 255, 40),
    BLEU(174, 214, 241),
    JAUNE(253, 255, 97),
    GRIS(160, 160, 160),
    NOIR(0, 0, 0);

  private int rouge;
  private int vert;
  private int bleu;

  Couleur(int rouge, int vert, int bleu) {
    this.rouge = rouge;
    this.vert = vert;
    this.bleu = bleu;
  }

  public int[] toRGB() {
    int[] rvb = {this.rouge, this.vert, this.bleu};
    return rvb;
  }
}

public class Data {
  String action;
  Couleur color_i;
  Shape shape;
  Point location;
  Forme forme;

  Data() {
    this.action="";
    this.color_i = null;
    this.shape = null;
    this.location = null;
  }

  public void setAction(String act) {
    this.action = act;
  }

  public void setColor(String c) {
    switch(c) {
    case "RED" :
      this.color_i=Couleur.ROUGE;
      break;
    case "BLUE" :
      this.color_i=Couleur.BLEU;
      break;
    case "YELLOW" :
      this.color_i=Couleur.JAUNE;
      break;
    case "GREEN" :
      this.color_i=Couleur.VERT;
      break;
    default:
      this.color_i=null;
      break;
    }
  }

  public void setShape(String shape) {
    switch(shape) {
    case "CIRCLE" :
      this.shape = Shape.CIRCLE;
      break;
    case "RECTANGLE" :
      this.shape = Shape.RECTANGLE;
      break;
    case "TRIANGLE" :
      this.shape = Shape.TRIANGLE;
      break;
    case "DIAMOND" :
      this.shape = Shape.DIAMOND;
      break;
    default:
      this.shape = null;
      break;
    }
  }

  public void setLocationPoint(Point pt) {
    this.location = pt;
  }

  public void reset() {
    this.action="";
    this.color_i = null;
    this.shape = null;
    this.location = null;
  }

  public boolean isDataCompleted() {
    return this.action != "" && this.color_i != null && this.shape != null && this.location != null;
  }

  public Forme getForme() {
    if (this.isDataCompleted()) {
      switch(this.shape) {
      case CIRCLE :
        this.forme = new Cercle(this.location);
        break;
      case RECTANGLE :
        this.forme = new Rectangle(this.location);
        break;
      case TRIANGLE :
        this.forme = new Triangle(this.location);
        break;
      case DIAMOND :
        this.forme = new Losange(this.location);
        break;
      default:
        this.forme = null;
        break;
      }

      this.forme.setColor(this.color_i);
      this.forme.setLocation(this.location);
      return this.forme;
    }
    return null;
  }

  public String toString() {
    return "Forme: act=" + this.action + " color=" + this.color_i + " shape=" + this.shape +" location="+  this.location ;
  }
}
/*
 * Enumération de a Machine à Etats (Finite State Machine)
 *
 *
 */
 
public enum FSM {
  INITIAL, /* Etat Initial */ 
  IDLE, 
  AFFICHER_FORMES, 
  EN_ATTENTE_INFORMATIONS,
  REALISATION_ACTION
}
/*****
 * Création d'un nouvelle classe objet : Forme (Cercle, Rectangle, Triangle
 *
 * Date dernière modification : 28/10/2019
 */

abstract class Forme {
  Point origin;
  Shape shape;
  Couleur c_color;
  int c;

  Forme() {
  }

  Forme(Point p) {
    this.origin=p;
    this.c_color = Couleur.NOIR;
    int[] rvb = c_color.toRGB();
    this.c= color(rvb[0], rvb[1], rvb[2]);
  }

  public void setColor(Couleur c) {
    this.c_color= c;
    int[] rvb = c.toRGB();
    this.c= color(rvb[0], rvb[1], rvb[2]);
  }

  public int getColor() {
    return(this.c);
  }

  public abstract void update();

  public Point getLocation() {
    return(this.origin);
  }

  public void setLocation(Point p) {
    this.origin = p;
  }

  public abstract boolean isClicked(Point p);

  // Calcul de la distance entre 2 points
  protected double distance(Point A, Point B) {
    PVector AB = new PVector( (int) (B.getX() - A.getX()), (int) (B.getY() - A.getY()));
    return(AB.mag());
  }

  protected abstract double perimetre();
  protected abstract double aire();
}
/*
 * Classe Losange
 */ 
 
public class Losange extends Forme {
  Point A, B,C,D;
  
  public Losange(Point p) {
    super(p);
    this.shape = Shape.DIAMOND;
    // placement des points
    A = new Point();    
    A.setLocation(p);
    B = new Point();    
    B.setLocation(A);
    C = new Point();  
    C.setLocation(A);
    D = new Point();
    D.setLocation(A);
    B.translate(40,60);
    D.translate(-40,60);
    C.translate(0,120);
  }
  
  public void setLocation(Point p) {
      super.setLocation(p);
      // redéfinition de l'emplacement des points
      A.setLocation(p);   
      B.setLocation(A);  
      C.setLocation(A);
      D.setLocation(A);
      B.translate(40,60);
      D.translate(-40,60);
      C.translate(0,120);   
  }
  
  public void update() {
    fill(this.c);
    quad((float) A.getX(), (float) A.getY(), (float) B.getX(), (float) B.getY(), (float) C.getX(), (float) C.getY(),  (float) D.getX(),  (float) D.getY());
  }  
  
  public boolean isClicked(Point M) {
    // vérifier que le losange est cliqué
    // aire du rectangle AMD + AMB + BMC + CMD = aire losange  
    if (round( (float) (aire_triangle(A,M,D) + aire_triangle(A,M,B) + aire_triangle(B,M,C) + aire_triangle(C,M,D))) == round((float) aire()))
      return(true);
    else 
      return(false);  
  }
  
  protected double perimetre() {
    //
    PVector AB= new PVector( (int) (B.getX() - A.getX()),(int) (B.getY() - A.getY())); 
    PVector BC= new PVector( (int) (C.getX() - B.getX()),(int) (C.getY() - B.getY())); 
    PVector CD= new PVector( (int) (D.getX() - C.getX()),(int) (D.getY() - C.getY())); 
    PVector DA= new PVector( (int) (A.getX() - D.getX()),(int) (A.getY() - D.getY())); 
    return( AB.mag()+BC.mag()+CD.mag()+DA.mag()); 
  }
  
  protected double aire(){
    PVector AC= new PVector( (int) (C.getX() - A.getX()),(int) (C.getY() - A.getY())); 
    PVector BD= new PVector( (int) (D.getX() - B.getX()),(int) (D.getY() - B.getY())); 
    return((AC.mag()*BD.mag())/2);
  } 
  
  private double perimetre_triangle(Point I, Point J, Point K) {
    //
    PVector IJ= new PVector( (int) (J.getX() - I.getX()),(int) (J.getY() - I.getY())); 
    PVector JK= new PVector( (int) (K.getX() - J.getX()),(int) (K.getY() - J.getY())); 
    PVector KI= new PVector( (int) (I.getX() - K.getX()),(int) (I.getY() - K.getY())); 
    
    return( IJ.mag()+JK.mag()+KI.mag()); 
  }
   
  // Calcul de l'aire d'un triangle par la méthode de Héron 
  private double aire_triangle(Point I, Point J, Point K){
    double s = perimetre_triangle(I,J,K)/2;
    double aire = s*(s-distance(I,J))*(s-distance(J,K))*(s-distance(K,I));
    return(sqrt((float) aire));
  }
}
/*
 * Classe Rectangle
 */ 
 
public class Rectangle extends Forme {
  
  int longueur;
  
  public Rectangle(Point p) {
    super(p);    
    this.shape = Shape.RECTANGLE;
    this.longueur=60;
  }
   
  public void update() {
    fill(this.c);
    square((int) this.origin.getX(),(int) this.origin.getY(),this.longueur);
  }  
  
  public boolean isClicked(Point p) {
    int x= (int) p.getX();
    int y= (int) p.getY();
    int x0 = (int) this.origin.getX();
    int y0 = (int) this.origin.getY();
    
    // vérifier que le rectangle est cliqué
    if ((x>x0) && (x<x0+this.longueur) && (y>y0) && (y<y0+this.longueur))
      return(true);
    else  
      return(false);
  }
  
  // Calcul du périmètre du carré
  protected double perimetre() {
    return(this.longueur*4);
  }
  
  protected double aire(){
    return(this.longueur*this.longueur);
  }
}
/*
 * Enumération de a Machine à Etats (Finite State Machine)
 *
 *
 */
 
public enum Shape {
  CIRCLE,
  TRIANGLE,
  RECTANGLE,
  DIAMOND
}
/*
 * Classe Triangle
 */ 
 
public class Triangle extends Forme {
  Point A, B,C;
  public Triangle(Point p) {
    super(p);    
    this.shape = Shape.TRIANGLE;
    // placement des points
    A = new Point();    
    A.setLocation(p);
    B = new Point();    
    B.setLocation(A);
    C = new Point();    
    C.setLocation(A);
    B.translate(40,60);
    C.translate(-40,60);
  }
  
    public void setLocation(Point p) {
      super.setLocation(p);
      // redéfinition de l'emplacement des points
      A.setLocation(p);   
      B.setLocation(A);  
      C.setLocation(A);
      B.translate(40,60);
      C.translate(-40,60);   
  }
  
  public void update() {
    fill(this.c);
    triangle((float) A.getX(), (float) A.getY(), (float) B.getX(), (float) B.getY(), (float) C.getX(), (float) C.getY());
  }  
  
  public boolean isClicked(Point M) {
    // vérifier que le triangle est cliqué
    
    PVector AB= new PVector( (int) (B.getX() - A.getX()),(int) (B.getY() - A.getY())); 
    PVector AC= new PVector( (int) (C.getX() - A.getX()),(int) (C.getY() - A.getY())); 
    PVector AM= new PVector( (int) (M.getX() - A.getX()),(int) (M.getY() - A.getY())); 
    
    PVector BA= new PVector( (int) (A.getX() - B.getX()),(int) (A.getY() - B.getY())); 
    PVector BC= new PVector( (int) (C.getX() - B.getX()),(int) (C.getY() - B.getY())); 
    PVector BM= new PVector( (int) (M.getX() - B.getX()),(int) (M.getY() - B.getY())); 
    
    PVector CA= new PVector( (int) (A.getX() - C.getX()),(int) (A.getY() - C.getY())); 
    PVector CB= new PVector( (int) (B.getX() - C.getX()),(int) (B.getY() - C.getY())); 
    PVector CM= new PVector( (int) (M.getX() - C.getX()),(int) (M.getY() - C.getY())); 
    
    if ( ((AB.cross(AM)).dot(AM.cross(AC)) >=0) && ((BA.cross(BM)).dot(BM.cross(BC)) >=0) && ((CA.cross(CM)).dot(CM.cross(CB)) >=0) ) { 
      return(true);
    }
    else
      return(false);
  }
  
  protected double perimetre() {
    //
    PVector AB= new PVector( (int) (B.getX() - A.getX()),(int) (B.getY() - A.getY())); 
    PVector AC= new PVector( (int) (C.getX() - A.getX()),(int) (C.getY() - A.getY())); 
    PVector BC= new PVector( (int) (C.getX() - B.getX()),(int) (C.getY() - B.getY())); 
    
    return( AB.mag()+AC.mag()+BC.mag()); 
  }
   
  // Calcul de l'aire du triangle par la méthode de Héron 
  protected double aire(){
    double s = perimetre()/2;
    double aire = s*(s-distance(B,C))*(s-distance(A,C))*(s-distance(A,B));
    return(sqrt((float) aire));
  }
}


  public void settings() { size(800, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Palette" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
